<MfpaCodeReviewRules>
    <rule name="dwContentShouldBeExternalizedIfLengthy" severity="WARNING">
        <ruleLogic>
			let $dwContentShouldBeExternalizedIfLengthy:= 
            for $eeTransformTag in $allXmlFilesContent//*:transform
				where $eeTransformTag/@muleAppName != '' 
                let $eeTransformContentLength:= fn:string-length(fn:normalize-space(
$eeTransformTag))
                let $ruleResult:= 
        
            <ruleResult lineAndColumnNumber="{data($eeTransformTag/@*:codeReviewLocation)}" 
                    ruleName="dwContentShouldBeExternalizedIfLengthy" 
                    muleAppName="{$eeTransformTag/@muleAppName}" 
                    muleFileName="{$eeTransformTag/@muleFileName}" 
                    muleFilePath="{$eeTransformTag/@muleFilePath}">
            {
                if($eeTransformContentLength > 1000)
                    then (
                        
                <suggestedFix>dw code from '{data($eeTransformTag/name())}' is long '{data($eeTransformContentLength)}', consider externalizing it to a dwl file under /src/main/resources for better change tracking</suggestedFix>
                    )
                else()
            }
            </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
        </ruleLogic>
    </rule>
    <rule name="asyncLoggersShouldNotBeSetInDebugMode" severity="WARNING">
        <ruleLogic>
			let $asyncLoggersShouldNotBeSetInDebugMode:=
 for $asyncLoggerInLog4j2 in $allXmlFilesContent//node() where $asyncLoggerInLog4j2/@muleAppName != '' and $asyncLoggerInLog4j2/@muleFileName = 'log4j2.xml' and data($asyncLoggerInLog4j2/name()) eq 'AsyncLogger'
     let $ruleResult:= 
     <ruleResult lineAndColumnNumber="{data($asyncLoggerInLog4j2/@*:codeReviewLocation)}" 
              ruleName="asyncLoggersShouldNotBeSetInDebugMode" 
              muleAppName="{$asyncLoggerInLog4j2/@muleAppName}" 
              muleFileName="{$asyncLoggerInLog4j2/@muleFileName}" 
              muleFilePath="{$asyncLoggerInLog4j2/@muleFilePath}">
        {
          if( (contains(string-join($asyncLoggerInLog4j2/@level,","),"DEBUG")))
            then(
              <suggestedFix>AsyncLogger with level = '{data($asyncLoggerInLog4j2/@level)}' is not allowed in production code</suggestedFix>
            )
          else()
        }
    </ruleResult>  where $ruleResult//suggestedFix != ""
return $ruleResult
        </ruleLogic>
    </rule>
    <rule name="tlsContextShouldNotAllowInsecureConnection" severity="CRITICAL">
        <ruleLogic>
			let $tlsContextShouldNotAllowInsecureConnection:=
			for $nodeWithInsecureAttribute in $allXmlFilesContent//node()[@insecure eq 'true']
				where $nodeWithInsecureAttribute/@muleAppName != '' 
				let $ruleResult:= 
				
            <ruleResult lineAndColumnNumber="{data($nodeWithInsecureAttribute/@*:codeReviewLocation)}" 
					ruleName="tlsContextShouldNotAllowInsecureConnection" 
					muleAppName="{$nodeWithInsecureAttribute/@muleAppName}" 
					muleFileName="{$nodeWithInsecureAttribute/@muleFileName}" 
					muleFilePath="{$nodeWithInsecureAttribute/@muleFilePath}">
                <suggestedFix>'tls-context' should not enable insecure connections, uncheck the option and use the CA signed certificates</suggestedFix>
            </ruleResult> where $ruleResult//suggestedFix != ""
			return $ruleResult
        </ruleLogic>
    </rule>
    <rule name="anyPasswordAttributeShouldBeSecured" severity="CRITICAL">
        <ruleLogic> 
        
    let $anyPasswordAttributeShouldBeSecured:=
    for $nodeWithPasswordAttribute in $allXmlFilesContent//node()[@password != '' or @keyPassword != ''] 
        where $nodeWithPasswordAttribute/@muleAppName != ''
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($nodeWithPasswordAttribute/@*:codeReviewLocation)}" 
                    ruleName="anyPasswordAttributeShouldBeSecured" 
                    muleAppName="{$nodeWithPasswordAttribute/@muleAppName}" 
                    muleFileName="{$nodeWithPasswordAttribute/@muleFileName}" 
                    muleFilePath="{$nodeWithPasswordAttribute/@muleFilePath}">
            {
                if(
                    boolean($nodeWithPasswordAttribute/@password) = true()
                    and
                    not(
                        starts-with($nodeWithPasswordAttribute/@password,'${secure')
                        or
                        starts-with($nodeWithPasswordAttribute/@password,'Mule::p(')
                        or
                        starts-with(data($nodeWithPasswordAttribute/@password),'${')
                        or
                        starts-with(data($nodeWithPasswordAttribute/@password), 'p(')
                        or
                        starts-with(data($nodeWithPasswordAttribute/@password),'#['))
                    )
                    then (
                        <suggestedFix>@password = '{data($nodeWithPasswordAttribute/@password)}' should be encrypted and externalized</suggestedFix>
                    )
                else if(
                    boolean($nodeWithPasswordAttribute/@keyPassword) = true()
                    and
                    not(
                        starts-with($nodeWithPasswordAttribute/@keyPassword,'${secure')
                        or
                        starts-with($nodeWithPasswordAttribute/@keyPassword,'Mule::p(')
                        or
                        starts-with(data($nodeWithPasswordAttribute/@keyPassword),'${')
                        or
                        starts-with(data($nodeWithPasswordAttribute/@keyPassword), 'p(')
                        or
                        starts-with(data($nodeWithPasswordAttribute/@keyPassword),'#['))
                )
                    then (
                        <suggestedFix>@keyPassword = '{data($nodeWithPasswordAttribute/@keyPassword)}' should be encrypted and externalized</suggestedFix>
                    )
                else()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult    
        
        </ruleLogic>
    </rule>
    <rule name="apiAutoDiscoveryIdConfiguration" severity="CRITICAL">
        <ruleLogic>

    let $apiAutoDiscoveryIdConfiguration:=
    for $autodiscovery in $allXmlFilesContent//*:autodiscovery where $autodiscovery/@muleAppName != ''
        let $apiId:= $autodiscovery/@apiId
        let $flowNameMatchingWithAutoDiscoveryFlowRef:=  $allXmlFilesContent//*:flow[@name = $autodiscovery/@flowRef]
        let $listenersInflowsMatchingAutoDiscoveryFlowRefValue:= $allXmlFilesContent//*:flow[@name = $autodiscovery/@flowRef]/*:listener
        let $routersInflowsMatchingAutoDiscoveryFlowRefValue:= $allXmlFilesContent//*:flow[@name = $autodiscovery/@flowRef]/*:router
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($autodiscovery/@*:codeReviewLocation),
                                          data($flowNameMatchingWithAutoDiscoveryFlowRef[@muleAppName != '']/@*:codeReviewLocation)}" 
                ruleName="apiAutoDiscoveryIdConfiguration" 
                muleAppName="{$autodiscovery/@muleAppName}" 
                muleFileName="{$autodiscovery/@muleFileName}" 
                muleFilePath="{$autodiscovery/@muleFilePath}">
            {
            if( not(contains(string-join($listenersInflowsMatchingAutoDiscoveryFlowRefValue/name(),","),"http:listener")) or 
                not(contains(string-join($routersInflowsMatchingAutoDiscoveryFlowRefValue/name(),","),"apikit:router")))
                then(
                <suggestedFix>autodiscovery with apiId = '{data($apiId)}' is available but could not find a http:listener or apikit:router in '{data($autodiscovery/@flowRef)}'</suggestedFix>
                )
            else if( not(data($apiId) eq '${api.autodiscoveryID}') )
                then( 
                    <suggestedFix>autodiscovery @apiId should be externalized with value equals '{data('\${api.autodiscoveryID}')}'</suggestedFix>
                )
            else()
            }
        </ruleResult>  where $ruleResult//suggestedFix != ""
    return $ruleResult

        </ruleLogic>
    </rule>
    <rule name="cronConfiguration" severity="CRITICAL">
        <ruleLogic>
    
    let $cronConfiguration:=
    for $cronNode in $allXmlFilesContent//*:cron where $cronNode/@muleAppName != ''
        let $cronExpression := $cronNode/@expression
        let $timeZoneExpression := $cronNode/@timeZone
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($cronNode/@*:codeReviewLocation)}" 
                    ruleName="cronConfiguration" 
                    muleAppName="{$cronNode/@muleAppName}" 
                    muleFileName="{$cronNode/@muleFileName}" 
                    muleFilePath="{$cronNode/@muleFilePath}">
            {
                if(
                    boolean($cronExpression) = true()
                    and
                    not(
                        starts-with(data($cronExpression),'Mule::p(')
                        or
                        starts-with(data($cronExpression),'p(')
                        or
                        starts-with(data($cronExpression),'${')
                        or
                        starts-with(data($cronExpression),'#[')
                        )
                    )
                    then(
                        <suggestedFix>cron expression with value '{data($cronExpression)}' should be externalized into property file</suggestedFix>
                    )
                else if (
                        boolean($timeZoneExpression) = true()
                        and
                        not(
                            starts-with(data($cronExpression),'Mule::p(')
                            or
                            starts-with(data($cronExpression),'p(')
                            or
                            starts-with($timeZoneExpression,'${')
                            or
                            starts-with( data($timeZoneExpression),'#[')
                            )
                    )
                    then(
                        <suggestedFix>cron timeZone with value '{data($timeZoneExpression)}' should be externalized into property file</suggestedFix>
                    )
                else ()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
    </ruleLogic>
    </rule>
    <rule name="connectionConfiguration" severity="CRITICAL">
        <ruleLogic>
    
    let $connectionConfiguration:=
    for $connection in $allXmlFilesContent//*[ends-with(local-name(), "-connection")] 
        where  $connection/@muleAppName != ''
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($connection/@*:codeReviewLocation)}" 
                    ruleName="connectionConfiguration" 
                    muleAppName="{$connection/@muleAppName}" 
                    muleFileName="{$connection/@muleFileName}" 
                    muleFilePath="{$connection/@muleFilePath}">
            {
                if( 
                    boolean($connection/@password) = true()
                    and
                    not (
                        starts-with($connection/@password,'Mule::p(')
                        or
                        starts-with(data($connection/@password),'${')
                        or
                        starts-with(data($connection/@password), 'p(')
                        or
                        starts-with(data($connection/@password),'#['))
                    )
                        then (
                            <suggestedFix>'{data($connection/name())}' with @password='{data($connection/@password)}' should be encrypted and externalized in to secured property file</suggestedFix>
                        )
                else if( 
                    boolean($connection/@host) = true()
                    and
                    not (
                        starts-with($connection/@host,'Mule::p(')
                        or
                        starts-with(data($connection/@host),'${')
                        or
                        starts-with(data($connection/@host), 'p(')
                        or
                        starts-with(data($connection/@host),'#['))
                    )
                        then (
                            <suggestedFix>'{data($connection/name())}' with @host='{data($connection/@host)}' should be externalized</suggestedFix>
                        )
                else if( 
                    boolean($connection/@port) = true()
                    and
                    not (
                        starts-with($connection/@port,'Mule::p(')
                        or
                        starts-with(data($connection/@port),'${')
                        or
                        starts-with(data($connection/@port), 'p(')
                        or
                        starts-with(data($connection/@port),'#['))
                    )
                        then (
                            <suggestedFix>'{data($connection/name())}' with @port='{data($connection/@port)}' should be externalized</suggestedFix>
                        )
                else if( 
                    boolean($connection/@user) = true()
                    and
                    not (
                        starts-with($connection/@user,'Mule::p(')
                        or
                        starts-with(data($connection/@user),'${')
                        or
                        starts-with(data($connection/@user), 'p(')
                        or
                        starts-with(data($connection/@user),'#['))
                    )
                        then (
                            <suggestedFix>'{data($connection/name())}' with @user='{data($connection/@user)}' should be externalized</suggestedFix>
                        )
                else if( 
                    boolean($connection/@username) = true()
                    and
                    not (
                        starts-with($connection/@username,'Mule::p(')
                        or
                        starts-with(data($connection/@username),'${')
                        or
                        starts-with(data($connection/@username), 'p(')
                        or
                        starts-with(data($connection/@username),'#['))
                    )
                        then (
                            <suggestedFix>'{data($connection/name())}' with @username='{data($connection/@username)}' should be externalized</suggestedFix>
                        )
                else ()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
        </ruleLogic>
    </rule>
    <rule name="connectorsConfiguration" severity="WARNING">
        <ruleLogic>
    
    let $connectorsConfiguration:=
    for $configNode in $allXmlFilesContent//*[ends-with(local-name(), "config")]  
        where data($configNode/name()) != 'apikit:config' and 
                data($configNode/name()) != 'spring:config' and
                data($configNode/name()) != 'secure-properties:config' and
                data($configNode/name()) != 'validation:config' and 
                data($configNode/name()) != 'http:listener-config' and 
                data($configNode/name()) != 'http:request-config' and 
                $configNode/@muleAppName != ''
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($configNode/@*:codeReviewLocation)}" 
                    ruleName="connectorsConfiguration" 
                    muleAppName="{$configNode/@muleAppName}" 
                    muleFileName="{$configNode/@muleFileName}" 
                    muleFilePath="{$configNode/@muleFilePath}">
            {
                if(boolean($configNode//*:reconnection) = false())
                    then (
                        <suggestedFix>reconnection-strategy for '{data($configNode/name())}' should be defined</suggestedFix>
                    )
                else ()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
        </ruleLogic>
    </rule>
    <rule name="docNameAttributesForXmlNodes" severity="WARNING">
        <ruleLogic>
    
    let $docNameAttributesForXmlNodes:=
    for $node in $allXmlFilesContent//node(),
        $attrName in $node/@*:name
        where $attrName != '' and 
                $node/name() != 'sub-flow' and 
                $node/name() != 'flow' and 
                data($attrName/name()) eq 'doc:name' and
                $node/@muleAppName != ''
    
        let $docNameValue:= $attrName
        let $nodeNameWithoutHyphensAndPrefix:= local:substringAfterLast(replace(local:getFileName($node/name()),'-',''),':')
        let $defaultDocNameTrimmed:= replace(normalize-space($docNameValue),' ','')
        let $flowReference:= 'Flow Reference'
        let $transformMessage:= 'Transform Message'
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($node/@*:codeReviewLocation)}" 
                    ruleName="docNameAttributesForXmlNodes" 
                    muleAppName="{$node/@muleAppName}" 
                    muleFileName="{$node/@muleFileName}" 
                    muleFilePath="{$node/@muleFilePath}">
            {
                if(lower-case(data($nodeNameWithoutHyphensAndPrefix)) eq lower-case($defaultDocNameTrimmed))
                    then (
                        <suggestedFix>doc:name attribute of '{$node/name()}' should be properly described for better GUI visualization</suggestedFix>
                        
                        )
                else if(lower-case($flowReference) eq lower-case($docNameValue))
                    then (
                        <suggestedFix>doc:name attribute of 'flow-ref' should be properly described for better GUI visualization</suggestedFix>
                        
                        )
                else if(lower-case($transformMessage) eq lower-case($docNameValue))
                    then (
                        <suggestedFix>doc:name attribute of 'ee:transform' should be properly described for better GUI visualization</suggestedFix>
                        
                        )
                else()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
    </ruleLogic>
    </rule>
    <rule name="emailAddressConfiguration" severity="CRITICAL">
        <ruleLogic>
    
    let $emailAddressConfiguration:=
    for $email in $allXmlFilesContent//*:send where $email/@muleAppName != ''
        let $emailFromAddress:=  $email/@fromAddress
        let $emailToAddress:=  $email/@toAddresses
        let $emailBccAddress:=  $email//*:bcc-addresses/*:bcc-address
        let $emailCcAddress:=  $email//*:cc-addresses/*:cc-address
        let $emailBccAddressList:= string-join($emailBccAddress/@value," ")
        let $emailCcAddressList:= string-join($emailCcAddress/@value," ")
        let $emailCcAddressListSize:= count(tokenize(string-join($emailCcAddress/@value," ")))
        let $emailBccAddressListSize:= count(tokenize(string-join($emailBccAddress/@value," ")))
        
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($email/@*:codeReviewLocation)}" 
                    ruleName="emailAddressConfiguration" 
                    muleAppName="{$email/@muleAppName}" 
                    muleFileName="{$email/@muleFileName}" 
                    muleFilePath="{$email/@muleFilePath}">
            {
                if(
                boolean($emailFromAddress) = true()
                and
                not(
                    starts-with(data($emailFromAddress),'Mule::p(')
                    or
                    starts-with(data($emailFromAddress),'p(')
                    or
                    starts-with(data($emailFromAddress),'${')
                    or
                    starts-with(data($emailFromAddress),'#[')
                    )
                )
                then (
                    <suggestedFix>@fromAddress '{data($emailFromAddress)}' should be externalized into property file</suggestedFix>
                    
                )
                else if(
                        boolean($emailToAddress) = true()
                        and
                        not(
                            starts-with(data($emailToAddress),'Mule::p(')
                            or
                            starts-with(data($emailToAddress),'p(')   
                            or
                            starts-with(data($emailToAddress),'${')
                            or
                            starts-with(data($emailToAddress),'#[')
                            )
                    )
                    then (
                        <suggestedFix>@toAddresses '{data($emailToAddress)}' should be externalized into property file</suggestedFix>
                        
                    )
                else if(
                    boolean($emailCcAddress) = true()
                    and
                    sum((
                        (count(tokenize($emailCcAddressList,"\$\{"))-1),
                        (count(tokenize($emailCcAddressList,"p\("))-1),
                        (count(tokenize($emailCcAddressList,"Mule::p\("))-1),
                        (count(tokenize($emailCcAddressList,"#\["))-1)
                        )) != $emailCcAddressListSize
                )
                then (
                    <suggestedFix>@cc-address '{data($emailCcAddressList)}' should be externalized into property file</suggestedFix>
                    
                )
                else if(
                        boolean($emailBccAddress) = true()
                        and
                        sum((
                            (count(tokenize($emailBccAddressList,"\$\{"))-1),
                            (count(tokenize($emailBccAddressList,"p\("))-1),
                            (count(tokenize($emailBccAddressList,"Mule::p\("))-1),
                            (count(tokenize($emailBccAddressList,"#\["))-1)
                            )) != $emailBccAddressListSize
                    )
                    then (
                        <suggestedFix>@bcc-address '{data($emailBccAddressList)}' should be externalized into property file</suggestedFix>
                    )
                else ()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
    </ruleLogic>
    </rule>
    <rule name="fixedFrequencyConfiguration" severity="CRITICAL">
        <ruleLogic>
    
    let $fixedFrequencyConfiguration:=
    for $fixedFrequency in $allXmlFilesContent//*:fixed-frequency where $fixedFrequency/@muleAppName != ''
        let $frequencyExpression := $fixedFrequency/@frequency
        let $startDelayExpression := $fixedFrequency/@startDelay
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($fixedFrequency/@*:codeReviewLocation)}" 
                    ruleName="fixedFrequencyConfiguration" 
                    muleAppName="{$fixedFrequency/@muleAppName}" 
                    muleFileName="{$fixedFrequency/@muleFileName}" 
                    muleFilePath="{$fixedFrequency/@muleFilePath}">
            {
                if(
                    boolean($frequencyExpression) = true()
                    and
                    not(
                        starts-with(data($frequencyExpression),'Mule::p(')
                        or
                        starts-with(data($frequencyExpression),'${')
                        or
                        starts-with(data($frequencyExpression),'#[')
                        )
                    )
                    then(
                        <suggestedFix>fixed frequency expression with value '{data($frequencyExpression)}' should be externalized into property file</suggestedFix>
                        )
                else if(
                        boolean($startDelayExpression) = true()
                        and
                        not(
                            starts-with(data($startDelayExpression),'Mule::p(')
                            or
                            starts-with($startDelayExpression,'${')
                            or
                            starts-with( data($startDelayExpression),'#[')
                            )
                        )
                        then(
                           <suggestedFix>fixed frequency startDelay expression with value '{data($startDelayExpression)}' should be externalized into property file</suggestedFix>
                        )
                else()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
    </ruleLogic>
    </rule>
    <rule name="flowNamingConventionAndDeclaration" severity="CRITICAL">
        <ruleLogic> 
    
    
    let $flowNamingConventionAndDeclaration:= 
    for $flow in $allXmlFilesContent//*:flow 
    where $flow/@muleAppName != ''
    let $fileNameWithoutExtensionPlusUnderscore :=  $flow/@muleFileNameWithoutExtension || "_"
    let $flowName := $flow/@name where contains(data($flowName), ':') = false()
    let $ruleResult:=  
    <ruleResult lineAndColumnNumber="{data($flow/@*:codeReviewLocation)}" 
                ruleName="flowNamingConventionAndDeclaration" 
                muleAppName="{$flow/@muleAppName}" 
                muleFileName="{$flow/@muleFileName}" 
                muleFilePath="{$flow/@muleFilePath}">
            {
                if(lower-case($flow/@muleFileName) eq 'global.xml')
                    then (
                        <suggestedFix>'{data($flowName)}' should not be declared in global file</suggestedFix>
                        )
                else if (
                        not(starts-with(data($flowName), $fileNameWithoutExtensionPlusUnderscore))
                        and
                        boolean($flow/*:router) = false()
                        and
                        boolean($flow/*:console) = false()
                        )
                        then (
                            <suggestedFix>name of flow '{data($flowName)}' should start with '{$fileNameWithoutExtensionPlusUnderscore}' (i.e. name of the flow-file)</suggestedFix>
                        )
                else if((count(tokenize(data($flowName),'_')) - 1) > 1)
                    then ( 
                            <suggestedFix>'{data($flowName)}':  _ can be used only to separate file-name and flow (or sub-flow) name</suggestedFix>
                    )
                else if(ends-with(upper-case(data($flowName)), "FLOW"))
                    then (
                            <suggestedFix>'{data($flowName)}' should not end with word 'flow'</suggestedFix>
                    )
                else()
            }
    </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult   
            
    
    
        </ruleLogic>
    </rule>
    <rule name="flowRefNameShouldMatchDocName" severity="CRITICAL">
        <ruleLogic>
    
    let $flowRefNameShouldMatchDocName:=
    for $flowRef in $allXmlFilesContent//*:flow-ref where $flowRef/@muleAppName != ''
        let $flowRefName:= $flowRef/@name
        let $flowRefDocName:=  $flowRef//@*:name[name() eq "doc:name"]
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($flowRef/@*:codeReviewLocation)}" 
            ruleName="flowRefNameShouldMatchDocName" 
            muleAppName="{$flowRef/@muleAppName}" 
            muleFileName="{$flowRef/@muleFileName}" 
            muleFilePath="{$flowRef/@muleFilePath}">
            {
                if(boolean(data($flowRef/@*:name/name()) = 'doc:name') = false())
                    then(
                            <suggestedFix>flow-ref with with name='{data($flowRef/@name)}' should have a doc:name attribute described for better GUI visualization</suggestedFix>
                        )
                else if(not(data($flowRefName) eq data($flowRefDocName)))
                    then (
                            <suggestedFix>flow-ref with name='{data($flowRef/@name)}' must have a doc:name exactly matching to that of name</suggestedFix>
                        )
                else()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult   
    
    </ruleLogic>
    </rule>
    <rule name="httpRequestConfigExternalized" severity="CRITICAL">
        <ruleLogic>
    
    let $httpRequestConfigExternalized:=
    for $requestConfig in $allXmlFilesContent//*:request-config[name() eq "http:request-config"] where $requestConfig/@muleAppName != ''
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($requestConfig/@*:codeReviewLocation)}" 
                    ruleName="httpRequestConfigExternalized" 
                    muleAppName="{$requestConfig/@muleAppName}" 
                    muleFileName="{$requestConfig/@muleFileName}" 
                    muleFilePath="{$requestConfig/@muleFilePath}">
            {
                if(
                    boolean($requestConfig/*:request-connection/@host) = true() 
                    and 
                    not(
                        starts-with(data($requestConfig/*:request-connection/@host), '${')
                        or
                        starts-with(data($requestConfig/*:request-connection/@host), '#[')
                        or
                        starts-with(data($requestConfig/*:request-connection/@host), 'p(')
                        or
                        starts-with(data($requestConfig/*:request-connection/@host), 'Mule::p('))
                    )
                    then (
                                <suggestedFix>host with value = '{data($requestConfig/*:request-connection/@host)}' should be externalized into property file</suggestedFix>
                        )
                else if(
                        boolean($requestConfig/*:request-connection/@port) = true() 
                        and 
                        not(
                            starts-with(data($requestConfig/*:request-connection/@port), '${')
                            or
                            starts-with(data($requestConfig/*:request-connection/@port), '#[')
                            or
                            starts-with(data($requestConfig/*:request-connection/@port), 'p(')
                            or
                            starts-with(data($requestConfig/*:request-connection/@port), 'Mule::p('))
                    )
                        then (
                            <suggestedFix>port with value = '{data($requestConfig/*:request-connection/@port)}' should be externalized into property file</suggestedFix>
                        )
                else ()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
    </ruleLogic>
    </rule>
    <rule name="httpRequestUrlExternalized" severity="CRITICAL">
        <ruleLogic>
    
    let $httpRequestUrlExternalized:=
    for $request in $allXmlFilesContent//*:request[name() eq "http:request"] where $request/@muleAppName != ''
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($request/@*:codeReviewLocation)}" 
                    ruleName="httpRequestUrlExternalized" 
                    muleAppName="{$request/@muleAppName}" 
                    muleFileName="{$request/@muleFileName}" 
                    muleFilePath="{$request/@muleFilePath}">
            {
                if(
                    boolean($request/@url) = true() 
                    and 
                    not(
                        starts-with(data($request/@url), '${')
                        or
                        starts-with(data($request/@url), '#[')
                        or
                        starts-with(data($request/@url), 'p(')
                        or
                        starts-with(data($request/@url), 'Mule::p('))
                    )
                    then (
                        <suggestedFix>url with value = '{data($request/@url)}' should be externalized into property file</suggestedFix>
                        
                    )
                    else ()
                }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
    </ruleLogic>
    </rule>
    <rule name="loggingWholePayloadOrMuleMessageObjectNotAllowed" severity="CRITICAL">
        <ruleLogic>
    
    let $loggingWholePayloadOrMuleMessageObjectNotAllowed:=
    for $loggerNode in $allXmlFilesContent//*:logger where $loggerNode/@muleAppName != ''
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($loggerNode/@*:codeReviewLocation)}" 
            ruleName="loggingWholePayloadOrMuleMessageObjectNotAllowed" 
            muleAppName="{$loggerNode/@muleAppName}" 
            muleFileName="{$loggerNode/@muleFileName}" 
            muleFilePath="{$loggerNode/@muleFilePath}">
            {
                if(data($loggerNode/@*:message) eq '#[message]')
                    then (
                            <suggestedFix>logger with message='{data($loggerNode/@*:message)}' is not allowed</suggestedFix>
                            )
                else if(data($loggerNode/@*:message) eq '#[payload]')
                    then (
                            <suggestedFix>logger with message='{data($loggerNode/@*:message)}' is not allowed</suggestedFix>
                            )
                else if(boolean($loggerNode/@*:message) = false())
                    then (
                            <suggestedFix>logger without message attribute is not allowed</suggestedFix>
                        )
                else if(data($loggerNode/@*:message) eq '')
                    then (
                            <suggestedFix>logger with message attribute without value is not allowed</suggestedFix>
                        )
                else()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult   
    
    </ruleLogic>
    </rule>
    <rule name="noGlobalPropertiesInNonGlobalFiles" severity="CRITICAL">
        <ruleLogic>
    
    let $noGlobalPropertiesInNonGlobalFiles:=
    for $rootMuleNodeOfEachMuleFile in $allXmlFilesContent//*:mule 
        where $rootMuleNodeOfEachMuleFile/name() != '' and 
                $rootMuleNodeOfEachMuleFile/@muleAppName != ''
        for $node in $rootMuleNodeOfEachMuleFile/node() where $node/name() != ''
            let $ruleResult:= 
            <ruleResult lineAndColumnNumber="{data($rootMuleNodeOfEachMuleFile/@*:codeReviewLocation)}" 
                        ruleName="noGlobalPropertiesInNonGlobalFiles" 
                        muleAppName="{$rootMuleNodeOfEachMuleFile/@muleAppName}" 
                        muleFileName="{$rootMuleNodeOfEachMuleFile/@muleFileName}" 
                        muleFilePath="{$rootMuleNodeOfEachMuleFile/@muleFilePath}">
                {
                    
                    if(
        
                        not(lower-case($rootMuleNodeOfEachMuleFile/@muleFileName) eq 'global.xml')
                        and 
                        not($node/name() eq "flow")
                        and 
                        not($node/name() eq "sub-flow")
                        
                        )
                        then (
                                <suggestedFix>'{data($node/name())}' should be defined in global.xml only</suggestedFix>
                                
                                )
                    else()
                            
                }
            </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
    </ruleLogic>
    </rule>
    <rule name="propFilesEnvironmentEnabled" severity="CRITICAL">
        <ruleLogic>
    
    let $propFilesEnvironmentEnabled:=
    for $configProperties in $allXmlFilesContent//*:configuration-properties 
    where $configProperties/@muleAppName != ''
    let $commonPropsConfig:= contains(lower-case(data($configProperties/@file)),"-common")
    let $ruleResult:= 
    <ruleResult lineAndColumnNumber="{data($configProperties/@*:codeReviewLocation)}" 
                ruleName="propFilesEnvironmentEnabled" 
                muleAppName="{$configProperties/@muleAppName}" 
                muleFileName="{$configProperties/@muleFileName}" 
                muleFilePath="{$configProperties/@muleFilePath}">
            {
    if(not(ends-with(data($configProperties/@file), '.yaml')))
        then (
            <suggestedFix>'{data($configProperties/@file)}' should be yaml based property files as per mule4 best practices</suggestedFix>
            
        )
    else if((not(contains(data($configProperties/@file), '${mule.env}')) = true()) and (data($commonPropsConfig) = false()))
        then (
            <suggestedFix>"{data($configProperties/@file)}" should contain "mule.env" environment property</suggestedFix>
            
        )
    else ()
    }
    </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
    </ruleLogic>
    </rule>
    <rule name="requestConnectionIsTLSEnabled" severity="WARNING">
        <ruleLogic>
    
    let $requestConnectionIsTLSEnabled:=
    for $connection in $allXmlFilesContent//*[ends-with(local-name(), "request-connection")]  
        where $connection/@muleAppName != ''
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($connection/@*:codeReviewLocation)}" 
                ruleName="requestConnectionIsTLSEnabled" 
                muleAppName="{$connection/@muleAppName}" 
                muleFileName="{$connection/@muleFileName}" 
                muleFilePath="{$connection/@muleFilePath}">
            {
                if(boolean($connection/@tlsContext) = false())
                    then (
                        <suggestedFix>request-connection '{data($connection/@host)}' should be TLS enabled</suggestedFix>
                    )
                else()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
    </ruleLogic>
    </rule>
    <rule name="recursiveFlowNames" severity="WARNING">
        <ruleLogic>
    
    let $recursiveFlowNames:=
    for $flow in $allXmlFilesContent//*:flow,
        $flowRef in $flow//*:flow-ref 
        where $flow/@muleAppName != ''
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($flow/@*:codeReviewLocation)},{data($flowRef/@*:codeReviewLocation)}" 
                ruleName="recursiveFlowNames" 
                muleAppName="{$flow/@muleAppName}" 
                muleFileName="{$flow/@muleFileName}" 
                muleFilePath="{$flow/@muleFilePath}">
            {
                if(data($flowRef/@name) eq $flow/@name)
                        then (
                            <suggestedFix>flow-ref with attribute name = '{data($flowRef/@name)}' is recursive and is not a best practice</suggestedFix>
                            
                        )
                else ()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
            
    </ruleLogic>
    </rule>
    <rule name="recursiveSubFlowNames" severity="WARNING">
        <ruleLogic>
    
    let $recursiveSubFlowNames:=
    for $subFlow in $allXmlFilesContent//*:sub-flow,
        $flowRef in $subFlow//*:flow-ref 
        where $subFlow/@muleAppName != ''
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($subFlow/@*:codeReviewLocation)},{data($flowRef/@*:codeReviewLocation)}" 
                ruleName="recursiveSubFlowNames" 
                muleAppName="{$subFlow/@muleAppName}" 
                muleFileName="{$subFlow/@muleFileName}" 
                muleFilePath="{$subFlow/@muleFilePath}">
            {
                if(data($flowRef/@name) eq $subFlow/@name)
                        then (
                            <suggestedFix>flow-ref with attribute name = '{data($flowRef/@name)}' is recursive and is not a best practice</suggestedFix>
                            
                        )
                else ()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
            
    
    </ruleLogic>
    </rule>
    <rule name="subFlowNamingConventionAndDeclaration" severity="CRITICAL">
        <ruleLogic>
    
    let $subFlowNamingConventionAndDeclaration:=
    
    for $subFlow in $allXmlFilesContent//*:sub-flow 
    where $subFlow/@muleAppName != ''
    let $subFlowName := $subFlow/@name
    let $fileNameWithoutExtensionPlusUnderscore:=  $subFlow/@muleFileNameWithoutExtension || "_"
    let $ruleResult:= 
    <ruleResult lineAndColumnNumber="{data($subFlow/@*:codeReviewLocation)}" 
                ruleName="subFlowNamingConventionAndDeclaration" 
                muleAppName="{$subFlow/@muleAppName}" 
                muleFileName="{$subFlow/@muleFileName}" 
                muleFilePath="{$subFlow/@muleFilePath}">
            {
        if(lower-case($subFlow/@muleFileName) eq 'global.xml')
        then (
                <suggestedFix>'{data($subFlowName)}' should not be declared in global file</suggestedFix>
            )
        else if (not(starts-with(data($subFlowName), $fileNameWithoutExtensionPlusUnderscore)))
            then (
            <suggestedFix>name of sub-flow '{data($subFlowName)}' should start with '{$fileNameWithoutExtensionPlusUnderscore}' (i.e. name of the flow-file)</suggestedFix>   
            )
        else if((count(tokenize(data($subFlowName),'_')) - 1) > 1)
        then (
                <suggestedFix>'{data($subFlowName)}' _ can be used only to separate file-name and flow (or sub-flow) name</suggestedFix>
            )
        else if(ends-with(upper-case(data($subFlowName)), "FLOW"))
        then (
                <suggestedFix>'{data($subFlowName)}' should not end with word 'flow'</suggestedFix>
            )
        else()
    }
    </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
        </ruleLogic>
    </rule>
    <rule name="securePropertiesConfigStandards" severity="CRITICAL">
        <ruleLogic>
    
    let $securePropertiesConfigStandards:=
    for $securePropertiesConfigNode in $allXmlFilesContent//*:config[name() eq 'secure-properties:config']
        where $securePropertiesConfigNode/@muleAppName != ''
        let $ruleResult:= 
        <ruleResult lineAndColumnNumber="{data($securePropertiesConfigNode/@*:codeReviewLocation)}" 
                        ruleName="securePropertiesConfigStandards" 
                        muleAppName="{$securePropertiesConfigNode/@muleAppName}" 
                        muleFileName="{$securePropertiesConfigNode/@muleFileName}" 
                        muleFilePath="{$securePropertiesConfigNode/@muleFilePath}">
            {
                    if(not(ends-with(data($securePropertiesConfigNode/@file), '.yaml')))
                        then (
                            <suggestedFix>'secure-properties-config' @file='{data($securePropertiesConfigNode/@file)}' should be yaml based property file as per mule4 best practices</suggestedFix>
                            )
                    else if(not(contains(data($securePropertiesConfigNode/@file), '${mule.env}')) = true())
                        then (
                            <suggestedFix>'secure-properties-config' @file='{data($securePropertiesConfigNode/@file)}' should contain "mule.env" environment property</suggestedFix>
                            )
                    else if(not(data($securePropertiesConfigNode/@key) eq '${encryptionKey}'))
                        then (
                            <suggestedFix>'secure-properties-config' @key='{data($securePropertiesConfigNode/@key)}' value should be defined as '{data('${encryptionKey}')}'</suggestedFix>
                            )
                    else ()
            }
        </ruleResult> where $ruleResult//suggestedFix != ""
    return $ruleResult
    
    </ruleLogic>
    </rule>
</MfpaCodeReviewRules>
